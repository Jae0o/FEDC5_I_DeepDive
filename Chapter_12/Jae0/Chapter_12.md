**수학에서의 함수란 ?**

**입력 input** 을 받아 **출력 output** 을 내보내는 일련의 과정

## 함수 Function

💡 일련의 과정을 **문 statement 으로 구현**하고 코드 블록으로 감싸 **하나의 실행 단위로 정의**한 것

- **매개변수 parameter**
  함수 내부로 입력을 전달받는 변수
- **인수 argument**
  입력 값 input
- **반환값 return value**
  출력 값 output

**함수 호출 function call** 을 통해 인수를 전달하면 함수 실행이 가능함

즉! JavaScript에서의 함수는 그냥 실행되는 것이 아닌

함수를 호출하면서 인수를 전달하게되고

인수 를 매개변수를 통해 함수 내부로 전달하고,

전달된 매개변수를 통해 함수 정의에 구현된 내용을 실행하여 결과 값을 반환 값으로 출력함

**일급 객체?**

변수 / 프로퍼티값으로도 될 수 있고 / 배열의 요소도 가능한 값의 성질을 갖는 객체를 말함

JavaScript 에서의 함수 또한 **일급 객체에 속함**

**사용 이유**

- 함수는 몇 번이든 호출할 수 있어 **코드의 재사용**이라는 측면에서 매우 유용함
- **코드의 중복**을 억제할 수 있음
- **유지보수의 편의성**이 높음
- 실수를 줄일수 있어서 **코드의 신뢰성**이 높음
- 함수에 이름을 지정하기 때문에 **코드의 가독성**을 높일 수 있음

## 함수 리터럴

💡 JavaScript에서의 함수는 객체Object 타입임

일반 객체와의 차이점?

일반 객체는 호출할 수 없지만 함수는 **호출이 가능함**

함수 리터럴은 **function 키워드 / 함수 이름 / 매개변수 목록 / 함수** 몸체 로 구성됨

- **함수 이름**
  - **식별자**로써 식별자 네이밍을 준수 해야함
  - 함수의 이름은 생략할 수 있음
    이름이 존재한다면 ⇒ 기명 함수 named function
    이름이 없다면 ⇒ 무명 / 익명 함수 anonymous function
- 매**개변수 목록**
  - 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분함 ( x , y )
  - 함수 호출 당시 전달한 인수가 순서대로 할당되어짐
    즉! 매개변수 목록은 순서에 의미가 있음
  - 함수 몸체내 ( 함수 정의 ) 내에서 변수와 동일한 취급을 받음
  - 매개변수의 최대 개수는 정해진것은 없음 하지만..
    ⇒ 함수는 **한 가지의 일만 처리하는것이 이상적**이기 때문에 가급적 적게 만드는것이 좋음
- **함수 몸체**
  - 실행될 문들을 하나의 실행 단위로 정의한 코드 블록
  - 함수 호출에 의해 실행됨

## 함수 정의

💡 함수를 호출하기 앞서 인수를 전달받을 **매개변수 / 실행 문 / 반환 값** 등을 지정하는 행동

**함수 선언문**

```jsx
function FuncName(x, y) {
  // 실행문들

  return "반환값";
}
```

- 함수 선언문에서는 함수 이름을 생략할 수 없음
  ⇒ 표현식이 아닌 하나의 문 statement 이기때문에
- JavaScript 에서는 함수 호출을 위해 함수이름을 사용하지않음
  ⇒ 함수 이름과 동일한 식별자를 **암묵적으로 생성**하고 거기에 함수 객체를 할당하여 **식별자를 호출함**
  즉, 🔥 함수 선언문은 **함수 표현식으로 변환되어 함수 객체를 생성하게됨**

**함수 표현식**

```jsx
// 이름 생략 가능
const FuncName = function (x, y) {
  // 실행문들

  return "반환값";
};
```

- 선언문에서 나온 개념과 같이 함수의 이름을 생략하고 생성시
  표현식이 식별자에 할당되어 실행되어지기때문에 선언문에서 생략가능

**함수 호이스팅**

```jsx
console.log(Func1); // f add (x,y)
console.log(Func2); // undefined

console.log(Func1(1, 2)); //3
console.log(Func2(1, 2)); // Error

function Func1(x, y) {
  return x + y;
}

var Func2 = function (x, y) {
  return x + y;
};
```

두 결과가 다른 이유는 함수 선언문 / 함수 표현식 으로 **정의한 함수의 생성 시점**이 다르기 때문

- 선언문으로 정의를 한후 호출하게되면 변수 호이스팅과같이 **함수 호이스팅**이 일어나게됨
- 예시와 같이 표현식을 호출 / 참조하게 된다면?
  ⇒ 함수 호이스팅이 일어나는것이 아닌 🔥 **변수 호이스팅이 일어남**
  따라서 변수 호이스팅으로 인해 변수가 초기화 되고 undefined가 반환되는것

**생성자 함수**

```jsx
const Name = new Function("x", "y", "return x+y");
```

- 사용하지 않는것을 권장
- 생성자를통해 생성한 함수는 클로저 생성.. 등 다양한 측면에서 표현식 / 선언문과 다르게 동작함

**화살표 함수**

```jsx
const Name = (x, y) => x + y;
```

- ES6 에서 도입된 기술로 간략하게 함수를 선언 할 수 있음
- 주의점 ⚠️ function 키워드를 완전히 대체하기위해 만들어진 기술이 아님
  - 생성자 함수로 사용할 수 없음
  - this의 바인딩 방식이 다름
  - 프로퍼티가 없고 arguments 객체또한 생성하지 않음

## 함수 호출

💡 함수를 가리키는 식별자 + 한 쌍의 소괄호로 된 함수 호출 연산자로 호출됨

- 매개변수는 함수를 정의할 때 선언됨
  ⇒ 함수 몸체 내에서 변수와 동일하게 취급됨
- 매개변수를 통해 함수의 내부로 전달되는 인수는 값으로 평가 될 수 있는 표현식이어야함
  ⇒ 갯수와 타입은 제한이 없음
- 🔥 즉, 함수가 호출되면 내부에 undefined로 초기화된 후 안수가 순서대로 매개변수에 할당되어짐

매개변수 기본값 ( ES6 에서 도입 )

```jsx
// x 와 y 에 전달된 인수가 없을 경우 0 으로 할당됨
function Func(x = 0, y = 0) {
  return x + y;
}

Func(2); // 2
```

위에서 언급했듯이 인수를 매개변수보다 적게 전달할 경우 빈자리의 매개변수는 undefined로 초기화됨

이런 불상사를 막기위해 매개변수로 전달된 인수가 없을 경우를 대비한 **기본값을 지정**할 수 있음

## 반환

💡 **return 키워드**와 **표현식 ( 반환값 )** 으로 이뤄진 반환문을 이용해 결과를 외부로 반환할 수 있음

- 반환문 이후에 다른 문이 존재하더라도 함수의 **실행을 종료**하고 함수 외부로 값을 반환함
  ⇒ 반환문 이후에 **다른 문들은 실행되지 않음**
- return 키워드 위 표현식을 평가한 후 반환함
  ⇒ 표현식을 제대로 전달하지 않으면 undefined 가 출력됨

## 함수의 형태

**즉시 실행 함수**

함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수라고 함 - 일회용 함수

```jsx
// 즉시 실행 함수
(function ( ){ return x + y } ( ) )
// 익명 함수로 사용하는것이 일반적

// 반드시 그룹 연산자로 감싸야함 ( ... )
function ( ){  }( ) // ERROR

function Name ( ){  }( ) // ERROR

```

**재귀 함수**

함수가 자기 자신을 호출하는 것을 **재귀 호출 recursive call** 이라고 함

**재귀 함수 recursive function** 은 자기 자신을 호출해 재귀 호출을 수행하는 함수

- 주로 반복되는 처리를 위해 사용됨
- 대부분의 재귀함수는 for / while 문으로 구현 가능함

```jsx
function countDown(num) {
  if (num === 0) return;
  console.log(num);
  countDown(num - 1);
}

countDown(10);
```

**중첩 함수**

함수 내부에 정의된 함수로 **내부 함수 inner function** 이라고도 함

주로 외부 함수를 돕는 **헬퍼 함수 역할을 함**

```jsx
function outer() {
  let x = 1;

  function inner() {
    let y = 2;
    console.log(x + y);
  }
  inner();
}

outer(); // 3
```

**🔥 콜백 함수**

💡 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 **콜백 함수 call back** 라고함

매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 **고차 함수 High-Order Function** 이라함

- 고차 함수는 콜백 함수를 자신으 일부분으로 합성함
- 콜백 함수는 **고차 함수에 의해 호출**되고, 고차 함수는 필요에 따라 **콜백 함수에 인수를 전달**할 수 있음

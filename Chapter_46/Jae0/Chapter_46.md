## 제너레이터

<aside>
💡 ES6에 도입된 기능으로 코드 블록의 실행을 일시 중지했다가 필요한 순간에 재개할 수 있는 함수

</aside>

**일반 함수와의 차이점**

- 제너레이터 함수는 함수 호출자에게 함수 실행의 제어권을 양도할 수 있
- 제너레이터 함수는 함수 호출자와 함수의 상태를 주고 받을 수 있음
- 제너레이터 함수를 호출하면 제너레이터 객체를 반환함

제너레이터 함수는 일반함수와 달리 `function*` 키워드로 선언되어짐 그리고 `yield` 표현식을 하나 이상 가짐

```jsx
function* name () { yield 1};

const name = * () => { yield 1};
```

🔥단 제너레이터 함수는 `new` 연산자와 함께 생성자 함수로 사용될순 없음

**제너레이터 객체**

일반 함수처럼 코드를 실행하면 코드블록이 실행되는것이 아니라 제너레이터 객체를 생성하여 반환함

반환된 제너레이터 객체는 `이터러블` 이면서 동시에 `이터레이터` 임

**일시 중지와 재개**

`yield` 키워드와 `next` 메서드를 통해 실행을 일시 중지하고 다시 재개 할 수 있음

가능한 이유는 일반 함수는 함수 실행 이후 제어권을 함수가 독점하지만 제너레이터는 제어권을 양도함

- `yield` 키워드는 함수를 **일시 중지** 시키거나 해당 키워드 뒤에 오는 **평가 결과를 함수 호출자 에게 반환**
- 이후 `next` 메서드를 호출시 다음 `yield` 까지 실행되고 일시 중지됨
- next 메서드는 `value` 와 `done` 이라는 프로퍼티를 갖는 이터레이터 결과 객체를 반환함
  `value` ⇒ `yield` 표현식에서 키워드 뒤의 값이 저장됨
  `done` ⇒ 함수가 끝까지 실행되었다면 `true`

# async await

<aside>
💡 ES8 에서 제너레이터보다 가동성 좋게 비동기 처리를 동기 처리처럼 동작하도록 도입됨

</aside>

일반적으로 Promise를 기반으로 동작함

### async

`async` 함수는 `async` 키워드를 사용해 정의하고 언제나 `Promise` 를 반환함

만약, 명시적으로 Promise를 반환하지 않더라고 암묵적으로 `resolve` 하는 Promise 를 반환함

### await

`await` 키워드는 반드시 `async` 함수 내부에서 사용되어야함

기본적으로 await 키워드는 Promise가 `settled` 상태가 될때까지 기다렸다가

상태가 변경되면 `resolve` 한 처리결과를 반환함

🔥 따라서 반드시 await 키워드는 `Promise` 앞에서 사용되어야함

### Error 처리

async await 에서는 Promise 를 반환하기 때문에 비동기 `try … catch` 를 통해 Error 처리가 가능함

🔥 단 Error 캐치는 async 함수 내에서 catch 문을 사용해야하며, 만약 error 를 처리하지 않으면,

async 함수 **reject하는 Promise** 를 반환하게

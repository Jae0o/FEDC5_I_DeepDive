# 원시 값과 객체의 비교

원시 값을 변수에 할당 => 메모리 공간에 실제 '값'이 저장 <br>
객체를 변수에 할당 => 메모리 공간에 '참조 값(주소)'이 저장

### 11.1 원시 값

변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 or 그 메모리 공간을 식별하기 위해 붙인 이름이고,<br> 값은 변수에 저장된 데이터로 표현식이 평가되어 생성된 결과다. <br>변경 불가능하다는 것은 변수가 아니라 값에 대한 진술이다. 그러므로, '원시 값은 변경 불가능하다'는 말은 <br>원시 값 자체를 변경할 수 없다는 것이지, 변수 값을 변경할 수 없다는 것이 아니다.
<br>

상수는 재할당이 금지된 변수이다.
<br> <br>
상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수라고 할 수 있다.<br>
상수는 단 한 번만 할당이 허용되므로 변수 값을 변경할 수 없다. <br>
따라서 상수와 변경 불가능한 값은 구분되어야 한다. <br>
상수는 재할당이 금지된 변수일 뿐이다.

또한 불변성을 갖는 원시 값을 할당한 변수는, 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다. <br>

<br>

### 11.2 객체

객체는 프로퍼티의 개수가 정해져 있지 않고, 동적으로 추가되고 삭제가 가능하며 값에도 제약이 없어 <br>확보해야 할 메모리 공간의 크기를 사전에 정해둘 수 없다.

<br>

#### JS 에서의 얕은 복사 vs 깊은 복사

만약, 객체를 프로퍼티 값으로 갖는 객체를 복사할 때,

- 얕은 복사 : 한 단계까지만 복사
- 깊은 복사 : 객체에 중첩되어 있는 객체까지 모두 복사

```js
const o = {
  x: {
    y: 1,
  },
};

// 얕은 복사
const c1 = { ...o };
console.log(c1 === o); // false
console.log(c1.x === o.x); // true

// 깊은 복사
const c2 = _.cloneDeep(o);
console.log(c2 === o); // false
console.log(c2.x === o.x); // false
```

또 다른 예시를 들자면

```js
var person = {
  name: "Lee",
};

// 얕은 복사
var copy = person;
```

![Alt text](./image.png)

위 사진과 같은 방식으로, 두 식별자가 하나의 객체를 공유한다.

# 에러의 전파

에러는 호출자 방향으로 전파된다.

즉 콜 스택의 아래 방향(실행 중인 실행 컨텍스트가 푸시되기 직전에 푸시된 실행 컨텍스트 방향으로) 전파된다.

```javascript
function foo() {
    throw new Error('foo에서 발생한 에러');
}

function bar() {
    foo();
}

function baz() {
    bar();
}

try {
    baz();
} catch (error) {
    console.error(error);
}
```

baz 함수를 호출하면 bar 함수가 호출되고 foo 함수가 호출되고 foo 함수에서 에러를 던지고 있다.

이때 foo 함수가 던진 에러는 호출자에게 전파되어 전역에서 캐치된다.

전역 실행 컨텍스트 -> baz 실행 컨텍스트 -> bar 실행 컨텍스트 -> foo 실행 컨텍스트

현재 콜 스택에 실행 컨텍스트가 쌓인 모양이다.

**foo에서 발생한 에러를 호출자 방향으로 bar -> baz -> 전역으로 전파되며 어느 실행 컨텍스트에서 에러를 적적히 캐치하여 대응한다면 프로그램이 갖에 종료되지 않고 복구할 수 있다.**

**만약 어느 실행 컨텍스트에서 throw된 에러를 캐치하지 않으면 프로그램은 강제 종료 된다.**

### 호출자가 없는 경우

주의 할 점은 비동기 함수인 seTimeout이나 프로미스 후속 처리 메서드의 콜백 함수는 호출자가 없다는 것이다.

이때 콜백 함수는 콜 스택에 있지않고 이벤트 루프의 태스크 큐나 마이크로태스크 큐에 저장되었다가 콜 스택이 비었을 때 푸시되어 실행된다.

이때 콜 스택이 비었고 콜백 함수는 가장 하부에 존재하게 되므로 전파할 호출자가 존재하지 않게 되는 것이다.

그래서 비동기 함수를 콜백으로 처리한다는 것은 에러 처리에 한계를 발생하는 것이다.
